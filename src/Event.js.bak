/**
 * Event - Cross browser events implementation using Yaex's API
 *
 *
 * @depends: Yaex.js | Core
 * @version 0.10
 * @license Dual licensed under the MIT and GPL licenses.
 */

+ ('Yaex', function ($) {
	'use strict';

	var rkeyEvent = /^key/;
	var rmouseEvent = /^(?:mouse|contextmenu)|click/;
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	var rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

	var returnTrue = function () {
		return true;
	};

	var returnFalse = function () {
		return false;
	};

	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {
			console.error(err);
		}
	}

	$.Yaex.Event = {
		global: {},

		add: function (elem, types, handler, data, selector) {
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj, specialEvents,
				type, namespaces, origType, handlers,
				elemData = $.data_priv.get(elem);

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if (!elemData) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			if (!handler.GUID) {
				handler.GUID = $.GUID++;
			}

			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = {};
			}

			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function (e) {
					// Discard the second event of a $.Yaex.Event.trigger() and
					// when an event is called after a page has unloaded
					if ((typeof Yaex !== typeof undefined) && (!e || $.Yaex.Event.triggered !== e.type)) {
						return $.Yaex.Event.dispatch.apply(eventHandle.elem, arguments);
					} else {
						return undefined;
					}
				};

				// Add elem as a property of the handle callback to prevent a memory leak with IE non-native events
				eventHandle.elem = elem;
			}

			// Handle multiple events separated by a space
			types = (types || '').match($.core_rnotwhite) || [''];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || '').split('.').sort();

				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				specialEvents = $.Yaex.Event.special[type] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? specialEvents.delegateType : specialEvents.bindType) || type;

				// Update specialEvents based on newly reset type
				specialEvents = $.Yaex.Event.special[type] || {};

				// handleObj is passed to all event handlers
				handleObj = $.Extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					GUID: handler.GUID,
					selector: selector,
					namespace: namespaces.join('.')
				}, handleObjIn);

				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if (!specialEvents.setup || specialEvents.setup.call(elem, data, namespaces, eventHandle) === false) {
						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle, false);
						}
					}
				}

				if (specialEvents.add) {
					specialEvents.add.call(elem, handleObj);

					if (!handleObj.handler.GUID) {
						handleObj.handler.GUID = handler.GUID;
					}
				}

				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}

				// Keep track of which events have ever been used, for event optimization
				$.Yaex.Event.global[type] = true;
			}

			// Nullify elem to prevent memory leaks in IE
			elem = null;
		},

		// Detach an event or set of events from an element
		remove: function (elem, types, handler, selector, mappedTypes) {
			var j, origCount, tmp, handlers,
				events, t, handleObj, specialEvents,
				type, namespaces, origType,
				elemData = $.data_priv.hasData(elem) && $.data_priv.get(elem);

			if (!elemData || !(events = elemData.events)) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = (types || '').match($.core_rnotwhite) || [''];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || '').split('.').sort();

				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						$.Yaex.Event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}

				specialEvents = $.Yaex.Event.special[type] || {};
				type = (selector ? specialEvents.delegateType : specialEvents.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');

				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];

					if ((mappedTypes || origType === handleObj.origType) &&
						(!handler || handler.GUID === handleObj.GUID) &&
						(!tmp || tmp.test(handleObj.namespace)) &&
						(!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
						handlers.splice(j, 1);

						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (specialEvents.remove) {
							specialEvents.remove.call(elem, handleObj);
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount && !handlers.length) {
					if (!specialEvents.teardown || specialEvents.teardown.call(elem, namespaces, elemData.handle) === false) {
						$.Yaex.RemoveEvent(elem, type, elemData.handle);
					}

					delete events[type];
				}
			}

			// Remove the expando if it's no longer used
			if ($.isEmptyObject(events)) {
				delete elemData.handle;
				$.data_priv.remove(elem, 'events');
			}
		},

		fix: function (event) {
			if (event[$.Expando]) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[type];

			if (!fixHook) {
				this.fixHooks[type] = fixHook =
					rmouseEvent.test(type) ? this.mouseHooks :
					rkeyEvent.test(type) ? this.keyHooks : {};
			}

			copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

			event = new $.Event(originalEvent);

			i = copy.length;

			while (i--) {
				prop = copy[i];
				event[prop] = originalEvent[prop];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if (!event.target) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome < 28
			// Target should not be a text node (#504, #13143)
			if (event.target.nodeType === 3) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
		},

		trigger: function (event, data, elem, onlyHandlers) {
			var i, cur, tmp, bubbleType, ontype, handle,
				eventPath = [elem || document],
				specialEvents,
				type = $.core_hasOwn.call(event, 'type') ? event.type : event,
				namespaces = $.core_hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + $.Yaex.Event.triggered)) {
				return;
			}

			if (type.indexOf('.') >= 0) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split('.');
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(':') < 0 && 'on' + type;

			// Caller can pass in a $.Event object, Object, or just an event type string
			event = event[$.Expando] ?
				event :
				new $.Event(type, typeof event === 'object' && event);

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join('.');
			event.namespace_re = event.namespace ?
				new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;

			if (!event.target) {
				event.target = elem;
			}

			if (!('defaultPrevented' in event)) {
				event.defaultPrevented = false;
				var prevent = event.preventDefault;
				event.preventDefault = function () {
					event.defaultPrevented = true;
					prevent.call(event);
				};
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] : $.makeArray(data, [event]);

			// Allow special events to draw outside the lines
			specialEvents = $.Yaex.Event.special[type] || {};

			if (!onlyHandlers && specialEvents.trigger && specialEvents.trigger.apply(elem, data) === false) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers && !specialEvents.noBubble && !$.isWindow(elem)) {

				bubbleType = specialEvents.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}

			// Fire handlers on the event path
			i = 0;

			while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

				event.type = i > 1 ?
					bubbleType :
					specialEvents.bindType || type;

				// jQuery handler
				handle = ($.data_priv.get(cur, 'events') || {})[event.type] && $.data_priv.get(cur, 'handle');
				if (handle) {
					handle.apply(cur, data);
				}

				// Native handler
				handle = ontype && cur[ontype];
				if (handle && $.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
					event.preventDefault();
				}
			}

			event.type = type;

			// If nobody prevented the default action, do it now
			if (!onlyHandlers && !event.isDefaultPrevented()) {

				if ((!specialEvents._default || specialEvents._default.apply(eventPath.pop(), data) === false) &&
					$.acceptData(elem)) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype && $.isFunction(elem[type]) && !$.isWindow(elem)) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];

						if (tmp) {
							elem[ontype] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						$.Yaex.Event.triggered = type;
						elem[type]();
						$.Yaex.Event.triggered = undefined;

						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		dispatch: function (event) {
			// Make a writable $.Event from the native event object
			event = $.Yaex.Event.fix(event);

			var i, j, ret, matched, handleObj = null;
			var handlerQueue = [],
				specialEvents;
			var args = $.core_slice.call(arguments);

			var handlers = ($.data_priv.get(this, 'events') || {})[event.type] || [];

			specialEvents = $.Yaex.Event.special[event.type] || {};

			// Use the fix-ed $.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (specialEvents.preDispatch && specialEvents.preDispatch.call(this, event) === false) {
				return;
			}

			// Determine handlers
			handlerQueue = $.Yaex.Event.handlers.call(this, event, handlers);

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;

			while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;

				j = 0;
				while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
					// Triggered event must either 1) have no namespace, or
					// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
					if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = (($.Yaex.Event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if (specialEvents.postDispatch) {
				specialEvents.postDispatch.call(this, event);
			}

			return event.result;
		},

		handlers: function (event, handlers) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {

				for (; cur !== this; cur = cur.parentNode || this) {

					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.disabled !== true || event.type !== 'click') {
						matches = [];
						for (i = 0; i < delegateCount; i++) {
							handleObj = handlers[i];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + ' ';

							/*if (matches[sel] === undefined) {
								matches[sel] = handleObj.needsContext ?
									$(sel, this).index(cur) >= 0 :
									$.find(sel, this, null, [cur]).length;
							}*/
							if (matches[sel]) {
								matches.push(handleObj);
							}
						}
						if (matches.length) {
							handlerQueue.push({
								elem: cur,
								handlers: matches
							});
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if (delegateCount < handlers.length) {
				handlerQueue.push({
					elem: this,
					handlers: handlers.slice(delegateCount)
				});
			}

			return handlerQueue;
		},

		simulate: function (type, elem, event, bubble) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = $.Extend(
				new $.Event(),
				event, {
					type: type,
					isSimulated: true,
					originalEvent: {}
				}
			);

			if (bubble) {
				$.Yaex.Event.trigger(e, null, elem);
			} else {
				$.Yaex.Event.dispatch.call(elem, e);
			}

			if (e.isDefaultPrevented()) {
				event.preventDefault();
			}
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),

		fixHooks: {},

		keyHooks: {
			props: 'char charCode key keyCode'.split(' '),
			filter: function (event, original) {

				// Add which for key events
				if (event.which == null) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
			filter: function (event, original) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if (event.pageX == null && original.clientX != null) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
					event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if (!event.which && button !== undefined) {
					event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
				}

				return event;
			}
		},

		special: {
			load: {
				noBubble: true
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function () {
					if (this !== safeActiveElement() && this.focus) {
						this.focus();
						return false;
					}
				},
				delegateType: 'focusin'
			},
			blur: {
				trigger: function () {
					if (this === safeActiveElement() && this.blur) {
						this.blur();
						return false;
					}
				},
				delegateType: 'focusout'
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function () {
					if (this.type === 'checkbox' && this.click && $.nodeName(this, 'input')) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function (event) {
					return $.nodeName(event.target, 'a');
				}
			},
			beforeunload: {
				postDispatch: function (event) {
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},
	};

	$.proxy = function (fn, context) {
		var tmp, args, proxy;

		if (typeof context === "string") {
			tmp = fn[context];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if (!$.isFunction(fn)) {
			throw new TypeError('expected function');
			// return undefined;
		}

		// Simulated bind
		args = $.core_slice.call(arguments, 2);

		proxy = function () {
			return fn.apply(context || this, args.concat($.core_slice.call(arguments)));
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.GUID = fn.GUID = fn.GUID || $.GUID++;

		return proxy;
	};

	$.fn.one = function (types, selector, data, callback) {
		return this.on(types, selector, data, callback, 1);
	};

	$.fn.live = function (event, callback) {
		$(document.body).delegate(this.selector, event, null, callback)
		return this
	};

	$.fn.die = function (event, callback) {
		$(document.body).undelegate(this.selector, event, null, callback)
		return this
	};

	$.fn.on = function (types, selector, data, callback, one) {
		var origFn;
		var type;

		// Types can be a map of types/handlers
		if (typeof types === 'object') {
			// (types-Object, selector, data)
			if (typeof selector !== 'string') {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}

			for (type in types) {
				this.on(type, selector, data, types[type], one);
			}

			return this;
		}

		if (data == null && callback == null) {
			// ( types, callback )
			callback = selector;
			data = selector = undefined;
		} else if (callback == null) {
			if (typeof selector === 'string') {
				// ( types, selector, callback )
				callback = data;
				data = undefined;
			} else {
				// ( types, data, callback )
				callback = data;
				data = selector;
				selector = undefined;
			}
		}
		if (callback === false) {
			callback = returnFalse;
		} else if (!callback) {
			return this;
		}

		if (one === 1) {
			origFn = callback;
			callback = function (event) {
				// Can use an empty set, since event contains the info
				$().off(event);
				return origFn.apply(this, arguments);
			};
			// Use same guid so caller can remove using origFn
			// callback.guid = origFn.guid || (origFn.guid = $.GUID++);
			callback.GUID = origFn.GUID || (origFn.GUID = $.GUID++);
		}

		return this.each(function () {
			$.Yaex.Event.add(this, types, callback, data, selector);
		});
	};

	$.fn.off = function (types, selector, callback) {
		var handleObj, type;

		if (types && types.preventDefault && types.handleObj) {
			// (event) dispatched $.Event
			handleObj = types.handleObj;

			$(types.delegateTarget).off(
				handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);

			return this;
		}

		if (typeof types === 'object') {
			// ( types-object [, selector] )
			for (type in types) {
				this.off(type, selector, types[type]);
			}

			return this;
		}
		if (selector === false || typeof selector === 'function') {
			// ( types [, callback] )
			callback = selector;
			selector = undefined;
		}
		if (callback === false) {
			callback = returnFalse;
		}

		return this.each(function () {
			$.Yaex.Event.remove(this, types, callback, selector);
		});
	};

	$.fn.trigger = function (type, data) {
		return this.each(function () {
			$.Yaex.Event.trigger(type, data, this);
		});
	};

	// triggers event handlers on current element just as if an event occurred,
	// doesn't trigger an actual event, doesn't bubble
	$.fn.triggerHandler = function (type, data) {
		var elem = this[0];

		if (elem) {
			return $.Yaex.Event.trigger(type, data, elem, true);
		}
	};

	$.Yaex.RemoveEvent = function (elem, type, handle) {
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle, false);
		}
	};

	// shortcut methods for `.bind(event, fn)` for each event type
	$.each(('focusin focusout load resize scroll unload click dblclick ' +
		'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
		'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
		$.fn[name] = function (data, callback) {
			return arguments.length > 0 ?
				this.on(name, null, data, callback) :
				this.trigger(name);
		};
	});

	['focus', 'blur'].forEach(function (name) {
		$.fn[name] = function (callback) {
			
			if (callback) {
				this.bind(name, callback);
			} else {
				this.each(function () {
					try {
						this[name]();
					} catch (e) {}
				});
			}

			return this;
		}
	});

	$.each({
		mouseenter: 'mouseover',
		mouseleave: 'mouseout'
	}, function (orig, fix) {
		$.Yaex.Event.special[orig] = {
			delegateType: fix,
			bindType: fix,
			handle: function (event) {
				var ret;
				var target = this;
				var related = event.relatedTarget;
				var handleObj = event.handleObj;

				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || (related !== target && !$.contains(target, related))) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}

				return ret;
			}
		};
	});

	// Create 'bubbling' focus and blur events
	// Support: Firefox, Chrome, Safari
	if (!$.Support.focusinBubbles) {
		$.each({
			focus: 'focusin',
			blur: 'focusout'
		}, function (orig, fix) {
			// Attach a single capturing handler while someone wants focusin/focusout
			var attaches = 0,
				handler = function (event) {
					$.Yaex.Event.simulate(fix, event.target, $.Yaex.Event.fix(event), true);
				};

			$.Yaex.Event.special[fix] = {
				setup: function () {
					if (attaches++ === 0) {
						document.addEventListener(orig, handler, true);
					}
				},
				teardown: function () {
					if (--attaches === 0) {
						document.removeEventListener(orig, handler, true);
					}
				}
			};
		});
	}

	$.fn.extend({
		hover: function (fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		},

		bind: function (types, data, callback) {
			return this.on(types, null, data, callback);
		},
		unbind: function (types, callback) {
			return this.off(types, null, callback);
		},

		delegate: function (selector, types, data, callback) {
			return this.on(types, selector, data, callback);
		},
		undelegate: function (selector, types, callback) {
			// ( namespace ) or ( selector, types [, callback] )
			return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', callback);
		}
	});

	$.Event = function (src, props) {
		// Allow instantiation without the 'new' keyword
		if (!(this instanceof $.Event)) {
			return new $.Event(src, props);
		}

		// Event object
		if (src && src.type) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = (src.defaultPrevented ||
				src.getPreventDefault && (!$.Browser.Firefox ? src.getPreventDefault() : src.defaultPrevented)) ? returnTrue : returnFalse;
			// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if (props) {
			$.Extend(this, props);
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || $.Now();

		// Mark it as fixed
		this[$.Expando] = true;
	};

	$.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function () {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if (e && e.preventDefault) {
				e.preventDefault();
			}
		},
		stopPropagation: function () {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if (e && e.stopPropagation) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function () {
			this.isImmediatePropagationStopped = returnTrue;
			this.stopPropagation();
		}
	};
})(Yaex)